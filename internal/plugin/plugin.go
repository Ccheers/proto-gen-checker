package plugin

import (
	"context"
	"fmt"

	"github.com/ccheers/proto-gen-checker/internal/config"
	"github.com/ccheers/proto-gen-checker/proto/checker"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"

	"google.golang.org/protobuf/proto"
)

const FmtPkg = protogen.GoImportPath("fmt")

type IPlugin interface {
	Generate(*protogen.Plugin) error
}

type IGenerator interface {
	Generator(ctx context.Context, file *protogen.GeneratedFile, field *protogen.Field, rule *checker.CheckRule) error
	Kind() protoreflect.Kind
}

type T struct {
	config *config.Config

	generators map[protoreflect.Kind]IGenerator
}

func New(config *config.Config, generators ...IGenerator) (*T, error) {
	mm := make(map[protoreflect.Kind]IGenerator, len(generators))
	for _, generator := range generators {
		_, ok := mm[generator.Kind()]
		if ok {
			return nil, fmt.Errorf("duplicate kind: %s", generator.Kind())
		}
		mm[generator.Kind()] = generator
	}
	return &T{
		config:     config,
		generators: mm,
	}, nil
}

func (x *T) Generate(plugin *protogen.Plugin) error {
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	ctx := context.TODO()
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		filename := file.GeneratedFilenamePrefix + ".checker.pb.go"
		g := plugin.NewGeneratedFile(filename, file.GoImportPath)

		g.P("// Code generated by github.com/ccheers/protoc-gen-checker. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()
		g.P("// This is a compile-time assertion to ensure that this generated file")
		g.P("// is compatible with the ccheers/protoc-gen-checker package it is being compiled against.")
		g.P()

		for _, message := range file.Messages {
			err := x.generateMessageCheckFunc(ctx, g, message)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (x *T) generateMessageCheckFunc(ctx context.Context, file *protogen.GeneratedFile, message *protogen.Message) error {
	file.P("func (x *", message.GoIdent, ") Check() error {")
	for _, field := range message.Fields {
		err := x.generateFieldCheckRule(ctx, file, field)
		if err != nil {
			return err
		}
	}
	file.P("return nil")
	file.P("}")
	return nil
}

func (x *T) generateFieldCheckRule(ctx context.Context, file *protogen.GeneratedFile, field *protogen.Field) error {
	checkRule, ok := proto.GetExtension(field.Desc.Options(), checker.E_Rule).(*checker.CheckRule)
	if !ok {
		return nil
	}
	generator, ok := x.generators[field.Desc.Kind()]
	if !ok {
		return fmt.Errorf("not support field kind: %s", field.Desc.Kind())
	}
	return generator.Generator(ctx, file, field, checkRule)
}
